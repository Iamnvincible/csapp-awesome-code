/* Return 1 when x contains an odd number of 1s; 0 otherwise.
Assume w=32
当 x 包含奇数个 1 时返回 1。
遵守整数位运算编程守则，可以假设 int 为 32 位。
*/
int odd_ones(unsigned x)
{
    x ^= x >> 16;
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >> 1;
    return x & 0x1;
}
/*题设要求遵守位运算规则，并限定运算数量 12 次。
一种想法是计算出数字中包含的 1 的数量，但位运算规则不能使用循环。
可以预见，题目并不需要具体 1 的数量，只需要判断数量是否是奇数即可。

如果整数中有奇数位 1，那么所有位异或在一起，结果应当为 1。
如果有偶数个 1,那么结果为 0。
由于题设限定只能运算 12 次，不能一位一位异或，需要多位同时异或。
可以折半异或，异或最终结果保存在最后一位中，将其和 1 相与，可去除前 31 位，得到结果。
思路类似 leetcode 136 题。

*/